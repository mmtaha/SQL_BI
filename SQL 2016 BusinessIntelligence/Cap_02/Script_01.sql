CREATE DATABASE ERP_IMPACTA;
go

USE PEDIDOS

go

USE PEDIDOS
-- 1. Criando a view
GO
CREATE VIEW VIE_EMPREGADO AS
SELECT CODFUN, NOME, DATA_ADMISSAO, 
       COD_DEPTO, COD_CARGO, SALARIO
FROM TB_EMPREGADO
GO
-- Testando a view
SELECT * FROM VIE_EMPREGADO
--

GO
CREATE FUNCTION FN_MAIOR( @N1 INT, @N2 INT )
  RETURNS INT
AS BEGIN
DECLARE @RET INT;
IF @N1 > @N2
   SET @RET = @N1
ELSE
   SET @RET = @N2;
RETURN (@RET)
END
GO
-- Testando
SELECT DBO.FN_MAIOR( 5,3 )
SELECT DBO.FN_MAIOR( 7,11 )

GO
CREATE FUNCTION FN_MAIOR_PEDIDO( @DT1 DATETIME,
                                 @DT2 DATETIME )
RETURNS TABLE
AS
RETURN ( SELECT MONTH( DATA_EMISSAO ) AS MES, 
                YEAR( DATA_EMISSAO ) AS ANO, 
                MAX( VLR_TOTAL ) AS MAIOR_VALOR
                FROM TB_PEDIDO
                WHERE DATA_EMISSAO BETWEEN @DT1 AND @DT2
                GROUP BY MONTH( DATA_EMISSAO ), 
                         YEAR( DATA_EMISSAO ) )

GO

-- Testando
SELECT * FROM DBO.FN_MAIOR_PEDIDO( '2014.1.1','2014.12.31')
ORDER BY ANO, MES

GO
CREATE FUNCTION FN_TOT_DEPTOS()
   RETURNS @TotDeptos TABLE ( COD_DEPTO INT, 
                              NOME VARCHAR(40),          
                              TIPO CHAR(1),
                              VALOR NUMERIC(12,2) )
AS BEGIN
DECLARE @I INT; -- Contador
DECLARE @TOT INT; -- Total de departamentos existentes
SELECT @TOT = MAX(COD_DEPTO) FROM TB_DEPARTAMENTO
SET @I = 1;
WHILE @I <= @TOT
   BEGIN
   -- Se existir o departamento de código = @I...
   IF EXISTS( SELECT * FROM TB_DEPARTAMENTO
              WHERE COD_DEPTO = @I )
      BEGIN
      -- Inserir na tabela de retorno os funcionários do
      -- departamento código @I
      INSERT INTO @TotDeptos
      SELECT COD_DEPTO, NOME, 'D', SALARIO 
      FROM TB_EMPREGADO WHERE COD_DEPTO = @I;
      -- Inserir na tabela de retorno uma linha contendo
      -- O total de salários do departamento @I
      -- Coloque no campo NOME a mensagem 'TOTAL' e no
      -- campo TIPO a letra 'T'. 
      -- O campo VALOR vai armazenar o total de salários
      INSERT INTO @TotDeptos
      SELECT COD_DEPTO, 'TOTAL DO DEPTO.:', 'T',
             SUM( SALARIO ) 
      FROM TB_EMPREGADO WHERE COD_DEPTO = @I
      GROUP BY COD_DEPTO;      
      END -- IF EXISTS
   SET @I = @I + 1;
   END -- WHILE
RETURN
END -- FUNCTION
GO
--
SELECT * FROM FN_TOT_DEPTOS()

USE PEDIDOS;

GO
CREATE PROCEDURE STP_TOTAL_VENDAS 
AS BEGIN
SELECT MONTH( DATA_EMISSAO ) AS MES,
       YEAR( DATA_EMISSAO ) AS ANO,
       SUM( VLR_TOTAL ) AS TOT_VENDIDO
FROM TB_PEDIDO
GROUP BY MONTH(DATA_EMISSAO), YEAR(DATA_EMISSAO)
ORDER BY MES
END
GO

--- Testando
EXEC STP_TOTAL_VENDAS

USE PEDIDOS;

GO
CREATE PROCEDURE STP_TOT_VENDIDO @ANO INT
AS BEGIN
SELECT MONTH( DATA_EMISSAO ) AS MES,
       YEAR( DATA_EMISSAO ) AS ANO,
       SUM( VLR_TOTAL ) AS TOT_VENDIDO
FROM TB_PEDIDO
WHERE YEAR(DATA_EMISSAO) = @ANO
GROUP BY MONTH(DATA_EMISSAO), YEAR(DATA_EMISSAO)
ORDER BY MES
END
GO

--- Testando
EXEC STP_TOT_VENDIDO 2014
EXEC STP_TOT_VENDIDO 2015

GO
CREATE PROCEDURE STP_ITENS_PEDIDO @DT1 DATETIME,
                                  @DT2 DATETIME,
                                  @CLIENTE VARCHAR(40) = '%', 
                                  @VENDEDOR VARCHAR(40) = '%'
AS BEGIN
SELECT 
  I.NUM_PEDIDO, I.NUM_ITEM, I.ID_PRODUTO, I.COD_PRODUTO,
  I.QUANTIDADE, I.PR_UNITARIO, I.DESCONTO, I.DATA_ENTREGA,
  PE.DATA_EMISSAO, PR.DESCRICAO, C.NOME AS CLIENTE,
  V.NOME AS VENDEDOR
FROM TB_PEDIDO PE
  JOIN TB_CLIENTE C ON PE.CODCLI = C.CODCLI
  JOIN TB_VENDEDOR V ON PE.CODVEN = V.CODVEN
  JOIN TB_ITENSPEDIDO I ON PE.NUM_PEDIDO = I.NUM_PEDIDO
  JOIN TB_PRODUTO PR ON I.ID_PRODUTO = PR.ID_PRODUTO
WHERE PE.DATA_EMISSAO BETWEEN @DT1 AND @DT2 AND
      C.NOME LIKE @CLIENTE AND V.NOME LIKE @VENDEDOR
ORDER BY I.NUM_PEDIDO
END

GO
CREATE PROCEDURE STP_COPIA_PRODUTO @ID_PRODUTO INT
AS BEGIN
DECLARE @ID_PRODUTO_NOVO INT;
-- Copia o registro existente para um novo registro
INSERT INTO TB_PRODUTO
( COD_PRODUTO, DESCRICAO, COD_UNIDADE, COD_TIPO, PRECO_CUSTO,
  PRECO_VENDA, QTD_ESTIMADA, QTD_REAL, QTD_MINIMA, CLAS_FISC,
  IPI, PESO_LIQ )
SELECT COD_PRODUTO, DESCRICAO, COD_UNIDADE, COD_TIPO, PRECO_CUSTO,
  PRECO_VENDA, QTD_ESTIMADA, QTD_REAL, QTD_MINIMA, CLAS_FISC,
  IPI, PESO_LIQ
FROM TB_PRODUTO
WHERE ID_PRODUTO = @ID_PRODUTO;
-- Descobre qual foi o ID_PRODUTO gerado
SET @ID_PRODUTO_NOVO = SCOPE_IDENTITY();
-- Retorna para a aplicação cliente o novo ID_PRODUTO gerado
PRINT @ID_PRODUTO_NOVO;  
END
GO
-- Testando
EXEC STP_COPIA_PRODUTO 10

GO
ALTER PROCEDURE STP_COPIA_PRODUTO @ID_PRODUTO INT
AS BEGIN
DECLARE @ID_PRODUTO_NOVO INT;
-- Copia o registro existente para um novo registro
INSERT INTO TB_PRODUTO
( COD_PRODUTO, DESCRICAO, COD_UNIDADE, COD_TIPO, PRECO_CUSTO,
  PRECO_VENDA, QTD_ESTIMADA, QTD_REAL, QTD_MINIMA, CLAS_FISC,
  IPI, PESO_LIQ )
SELECT COD_PRODUTO, DESCRICAO, COD_UNIDADE, COD_TIPO, PRECO_CUSTO,
  PRECO_VENDA, QTD_ESTIMADA, QTD_REAL, QTD_MINIMA, CLAS_FISC,
  IPI, PESO_LIQ
FROM TB_PRODUTO
WHERE ID_PRODUTO = @ID_PRODUTO;
-- Descobre qual foi o ID_PRODUTO gerado
SET @ID_PRODUTO_NOVO = SCOPE_IDENTITY();
-- Retorna para a aplicação cliente o novo ID_PRODUTO gerado
SELECT @ID_PRODUTO_NOVO AS ID_PRODUTO_NOVO;  
END
GO
-- Testando
EXEC STP_COPIA_PRODUTO 10

GO

ALTER PROCEDURE STP_COPIA_PRODUTO @ID_PRODUTO INT,
                                  @ID_PRODUTO_NOVO INT OUTPUT
AS BEGIN
-- Copia o registro existente para um novo registro
INSERT INTO TB_PRODUTO
( COD_PRODUTO, DESCRICAO, COD_UNIDADE, COD_TIPO, PRECO_CUSTO,
  PRECO_VENDA, QTD_ESTIMADA, QTD_REAL, QTD_MINIMA, CLAS_FISC,
  IPI, PESO_LIQ )
SELECT COD_PRODUTO, DESCRICAO, COD_UNIDADE, COD_TIPO, PRECO_CUSTO,
  PRECO_VENDA, QTD_ESTIMADA, QTD_REAL, QTD_MINIMA, CLAS_FISC,
  IPI, PESO_LIQ
FROM TB_PRODUTO
WHERE ID_PRODUTO = @ID_PRODUTO;
-- Descobre qual foi o ID_PRODUTO gerado
SET @ID_PRODUTO_NOVO = SCOPE_IDENTITY();
END
GO
-- Testando
DECLARE @IDPROD INT;
EXEC STP_COPIA_PRODUTO 10, @IDPROD OUTPUT;
PRINT 'NOVO PRODUTO = ' + CAST(@IDPROD AS VARCHAR(5));

GO

--Declara as variáveis de apoio
DECLARE @COD_SUP INT, @SUPERVISOR VARCHAR(35), @QTD INT

--Declara o cursor selecionando os supervisores
DECLARE CURSOR_SUPERVIDOR CURSOR FORWARD_ONLY FOR
SELECT DISTINCT COD_SUPERVISOR FROM TB_EMPREGADO WHERE COD_SUPERVISOR IS NOT NULL

-- Abre o Cursor
OPEN CURSOR_SUPERVIDOR

-- Movimenta o Cursor para a 1ª linha
FETCH NEXT FROM CURSOR_SUPERVIDOR INTO @COD_SUP;

-- Enquanto o cursor possuir linhas, a variável @@FETCH_STATUS estará com valor 0
WHILE @@FETCH_STATUS = 0
	BEGIN
		-- Busca o nome do Supervisor
		SELECT	@SUPERVISOR = NOME	FROM TB_EMPREGADO
      WHERE CODFUN = @COD_SUP
		-- Busca a quantidade de subordinados do supervisor
		SELECT	@QTD = COUNT(*)		FROM TB_EMPREGADO
           WHERE COD_SUPERVISOR = @COD_SUP 
           AND CODFUN <> @COD_SUP
		-- Apresenta a informação
	PRINT	@SUPERVISOR + ' - ' + CAST(@QTD AS VARCHAR(3)) + ' Subordinados'

		-- Move o cursor para a próxima linha
		FETCH NEXT FROM CURSOR_SUPERVIDOR INTO @COD_SUP;
	END
--Fecha o cursor
CLOSE		CURSOR_SUPERVIDOR
-- Remove da memória
DEALLOCATE	CURSOR_SUPERVIDOR


--Boa práticas

UPDATE TB_PRODUTO SET PRECO_VENDA = PRECO_VENDA * 1.2

SET NOCOUNT ON

UPDATE TB_PRODUTO SET PRECO_VENDA = PRECO_VENDA * 1.2


UPDATE TB_PRODUTO SET PRECO_VENDA = PRECO_VENDA * 1.2

SELECT @@ROWCOUNT AS QTD


--Query dinâmicas

EXEC('SELECT * FROM TB_PEDIDO' )
---

DECLARE @SQL VARCHAR(300)

SET @SQL = 'SELECT * FROM TB_PEDIDO'
EXEC( @SQL )
---

DECLARE @SQL VARCHAR(300) , @CODCLI INT

SET @CODCLI = 5

SET @SQL = 'SELECT * FROM TB_PEDIDO WHERE CODCLI=' + CAST(@CODCLI AS VARCHAR(5)) 
EXEC( @SQL )

-- Comandos úteis

USE PEDIDOS

-- Criação da tabela TB_CLIENTE_SP a partir da TB_CLIENTE
SELECT * INTO TB_CLIENTE_SP FROM TB_CLIENTE
WHERE CIDADE ='SAO PAULO'

-- Exclui os 10 primeiros registros da TB_CLIENTE_SP
DELETE TOP(10) TB_CLIENTE_SP

---

SELECT * FROM TB_CLIENTE
INTERSECT
SELECT * FROM TB_CLIENTE_SP 


--

SELECT * FROM TB_CLIENTE
EXCEPT
SELECT * FROM TB_CLIENTE_SP 

--

SELECT * FROM TB_CLIENTE_SP 
EXCEPT
SELECT * FROM TB_CLIENTE

--Lag e Lead

SELECT 
C.CODCLI,
YEAR(DATA_EMISSAO) AS ANO,
MONTH(DATA_EMISSAO) AS MES,
P.VLR_TOTAL AS VALOR_ATUAL,
LAG(VLR_TOTAL, 1) OVER (ORDER BY NUM_PEDIDO) AS PEDIDO_ANTERIOR,
LEAD(VLR_TOTAL, 1) OVER (ORDER BY NUM_PEDIDO) AS PEDIDO_POSTERIOR
FROM TB_CLIENTE AS C
JOIN TB_PEDIDO AS P ON P.CODCLI = C.CODCLI
WHERE C.CODCLI=30
ORDER BY 1,2,3


--Merge

USE PEDIDOS;

-- Caso exista a tabela
DROP TABLE EMP_TEMP

-- Criando a tabela a partir da tabela TB_Empregado
SELECT * INTO EMP_TEMP FROM TB_EMPREGADO; 

--Contando os registros
SELECT COUNT(*) 
FROM 
	(SELECT NOME,NUM_DEPEND,DATA_NASCIMENTO,COD_DEPTO,
	COD_CARGO,DATA_ADMISSAO,SALARIO,PREMIO_MENSAL,SINDICALIZADO,COD_SUPERVISOR
	FROM EMP_TEMP
	INTERSECT 
	SELECT NOME,NUM_DEPEND,DATA_NASCIMENTO,COD_DEPTO,
	COD_CARGO,DATA_ADMISSAO,SALARIO,PREMIO_MENSAL,SINDICALIZADO,COD_SUPERVISOR
	FROM TB_EMPREGADO
) AS  C

DELETE FROM EMP_TEMP WHERE COD_CARGO = 3;

UPDATE EMP_TEMP SET SALARIO *= 1.2
WHERE COD_DEPTO = 2

--Contando os registros
SELECT COUNT(*) 
FROM 
	(SELECT NOME,NUM_DEPEND,DATA_NASCIMENTO,COD_DEPTO,
	COD_CARGO,DATA_ADMISSAO,SALARIO,PREMIO_MENSAL,SINDICALIZADO,COD_SUPERVISOR
	FROM EMP_TEMP
	INTERSECT 
	SELECT NOME,NUM_DEPEND,DATA_NASCIMENTO,COD_DEPTO,
	COD_CARGO,DATA_ADMISSAO,SALARIO,PREMIO_MENSAL,SINDICALIZADO,COD_SUPERVISOR
	FROM TB_EMPREGADO
) AS  C


SET IDENTITY_INSERT EMP_TEMP ON

MERGE EMP_TEMP AS ET    -- Tabela alvo
USING TB_EMPREGADO AS E   -- Tabela fonte
ON ET.CODFUN = E.CODFUN -- Condição de comparação
WHEN MATCHED THEN
     UPDATE SET ET.SALARIO = E.SALARIO
WHEN NOT MATCHED THEN
     INSERT 
	 (CODFUN,NOME,NUM_DEPEND,DATA_NASCIMENTO,COD_DEPTO,COD_CARGO,
	  DATA_ADMISSAO,SALARIO,PREMIO_MENSAL,SINDICALIZADO,OBS,
	  FOTO,COD_SUPERVISOR)     
     VALUES 
	 (CODFUN,NOME,NUM_DEPEND,DATA_NASCIMENTO,COD_DEPTO,COD_CARGO,
	  DATA_ADMISSAO,SALARIO,PREMIO_MENSAL,SINDICALIZADO,OBS,
	  FOTO,COD_SUPERVISOR);


--Contando os registros
SELECT COUNT(*) 
FROM 
	(SELECT NOME,NUM_DEPEND,DATA_NASCIMENTO,COD_DEPTO,
	COD_CARGO,DATA_ADMISSAO,SALARIO,PREMIO_MENSAL,SINDICALIZADO,COD_SUPERVISOR
	FROM EMP_TEMP
	INTERSECT 
	SELECT NOME,NUM_DEPEND,DATA_NASCIMENTO,COD_DEPTO,
	COD_CARGO,DATA_ADMISSAO,SALARIO,PREMIO_MENSAL,SINDICALIZADO,COD_SUPERVISOR
	FROM TB_EMPREGADO
) AS  C


-- 2.9.4.	ROW_NUMBER

USE PEDIDOS
GO
SELECT NOME , TOTAL, ROW_NUMBER() OVER (ORDER BY TOTAL DESC) AS LINHA
FROM 
(SELECT  C.NOME , SUM(P.VLR_TOTAL) AS TOTAL
	FROM	TB_PEDIDO AS P
	JOIN	TB_CLIENTE AS C ON C.CODCLI = P.CODCLI
	GROUP BY C.NOME
	) AS A


SELECT NOME , QTD_PEDIDOS, ESTADO, ROW_NUMBER() OVER (PARTITION BY ESTADO ORDER BY QTD_PEDIDOS DESC) AS LINHA
FROM 
(SELECT  C.NOME , C.ESTADO, COUNT(*) AS QTD_PEDIDOS
	FROM	TB_PEDIDO AS P
	JOIN	TB_CLIENTE AS C ON C.CODCLI = P.CODCLI
	GROUP BY C.NOME, C.ESTADO
	) AS A

--Rank
USE PEDIDOS
GO
SELECT NOME , QTD_PEDIDOS, RANK() OVER (ORDER BY QTD_PEDIDOS DESC) AS [CLASSIFICAÇÃO]

FROM 
(SELECT  C.NOME , COUNT(*) AS QTD_PEDIDOS
	FROM	TB_PEDIDO AS P
	JOIN	TB_CLIENTE AS C ON C.CODCLI = P.CODCLI
	GROUP BY C.NOME
	) AS A


SELECT NOME , ESTADO,  QTD_PEDIDOS, RANK() OVER (PARTITION BY ESTADO ORDER BY QTD_PEDIDOS DESC) AS [CLASSIFICAÇÃO]
FROM 
(SELECT  C.NOME , C.ESTADO, COUNT(*) AS QTD_PEDIDOS
	FROM	TB_PEDIDO AS P
	JOIN	TB_CLIENTE AS C ON C.CODCLI = P.CODCLI
	GROUP BY C.NOME, C.ESTADO
	) AS A
Order by Estado

-- DENSE_RANK 

USE PEDIDOS

GO

SELECT NOME , QTD_PEDIDOS, DENSE_RANK() OVER (ORDER BY QTD_PEDIDOS DESC) AS [CLASSIFICAÇÃO]

FROM 
(SELECT  C.NOME , COUNT(*) AS QTD_PEDIDOS
	FROM	TB_PEDIDO AS P
	JOIN	TB_CLIENTE AS C ON C.CODCLI = P.CODCLI
	GROUP BY C.NOME
	) AS A

SELECT NOME , ESTADO,  QTD_PEDIDOS, DENSE_RANK() OVER (PARTITION BY ESTADO ORDER BY QTD_PEDIDOS DESC) AS [CLASSIFICAÇÃO]
FROM 
(SELECT  C.NOME , C.ESTADO, COUNT(*) AS QTD_PEDIDOS
	FROM	TB_PEDIDO AS P
	JOIN	TB_CLIENTE AS C ON C.CODCLI = P.CODCLI
	GROUP BY C.NOME, C.ESTADO
	) AS A
Order by Estado

--NTILE
SELECT NOME , TOTAL, ESTADO, NTILE (10) OVER (ORDER BY TOTAL DESC) AS GRUPO
FROM 
(SELECT  C.NOME , C.ESTADO, SUM(P.VLR_TOTAL) AS TOTAL
	FROM	TB_PEDIDO AS P
	JOIN	TB_CLIENTE AS C ON C.CODCLI = P.CODCLI
	GROUP BY C.NOME, C.ESTADO
	) AS A


-- ROW_NUMBER, RANK, DENSE_RANK e NTILE


SELECT NOME , ESTADO, QTD_PEDIDOS, 
ROW_NUMBER() OVER (PARTITION BY ESTADO ORDER BY QTD_PEDIDOS DESC) AS ROW_NUMBER,
RANK()		 OVER (PARTITION BY ESTADO ORDER BY QTD_PEDIDOS DESC) AS RANK,
DENSE_RANK() OVER (PARTITION BY ESTADO ORDER BY QTD_PEDIDOS DESC) AS DENSE_RANK,
NTILE (10)	 OVER (PARTITION BY ESTADO ORDER BY QTD_PEDIDOS DESC) AS NTILE
FROM 
(SELECT  C.NOME ,C.ESTADO, COUNT(*) AS QTD_PEDIDOS
	FROM	TB_PEDIDO AS P
	JOIN	TB_CLIENTE AS C ON C.CODCLI = P.CODCLI
	GROUP BY C.NOME,C.ESTADO
	) AS A
